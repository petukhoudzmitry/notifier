name: Generate pages from Docker proxy and publish to GitHub Pages

on:
  workflow_dispatch:
  repository_dispatch:
    types: [ external_trigger ]

permissions:
  contents: write
  pages: write
  id-token: write
  issues: write

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    env:
      IMAGE: ghcr.io/sarperavci/cloudflarebypassforscraping:latest
      IMAGE_NAME: cloudflarebypass
      PORT: 8000
      TARGET_URL: "visas-it.tlscontact.com"

    steps:
      - name: Cache Docker image
        uses: actions/cache@v5.0.1
        with:
          path: /tmp/docker-images
          key: docker-image-${{ env.IMAGE_NAME }}

      - name: Load image if cached
        run: |
          mkdir -p /tmp/docker-images
          if [ -f /tmp/docker-images/$IMAGE_NAME.tar ]; then
            docker load < /tmp/docker-images/$IMAGE_NAME.tar
          fi

      - name: Pull image if not cached
        run: |
          if ! docker image inspect $IMAGE > /dev/null 2>&1; then
            docker pull $IMAGE
            docker save $IMAGE > /tmp/docker-images/$IMAGE_NAME.tar
          fi
    
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Ensure old container is removed and run Docker container
        run: |
          docker rm -f pagegen 2>/dev/null || true
          docker run -d --name pagegen -p ${PORT}:${PORT} $IMAGE

      - name: Wait for local service on localhost:${PORT} (max 90s)
        run: |
          set -euo pipefail
          echo "Waiting up to 90s for http://localhost:${PORT}/ to respond..."
          i=0
          while [ $i -lt 90 ]; do
            status=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:${PORT}/" || echo "000")
            echo "  attempt $((i+1)) -> HTTP status: $status"
            if [ "$status" != "000" ]; then
              echo "Service responded!"
              break
            fi
            i=$((i+1))
            sleep 1
          done

          status=$(curl -s -o /dev/null -w "%{http_code}" "http://localhost:${PORT}/" || echo "000")
          if [ "$status" = "000" ]; then
            echo "Container did not respond in time. Dumping container logs..."
            docker logs --tail 200 pagegen || true
            exit 1
          fi

      - name: Test container->internet connectivity (inside container)
        run: |
          echo "Testing container->internet by requesting target via proxy inside the container..."
          curl -v "http://127.0.0.1:${PORT}" -H "x-hostname: $TARGET_URL" || true
          echo "Finished internal test (errors above captured but won't stop the job)."

      - name: Create public folder
        run: mkdir -p public

      - name: Fetch HTML pages from container (Cloudflare-safe)
        run: |
          set -euo pipefail
          
          URLS=(
            "https://visas-it.tlscontact.com/en-us/country/by/vac/byMSQ2it/news"
            "https://visas-it.tlscontact.com/ru-ru/country/by/vac/byMSQ2it/news"
            "https://visas-it.tlscontact.com/it-it/country/by/vac/byMSQ2it/news"
          )
          
          for url in "${URLS[@]}"; do
            lang_code=$(echo "$url" | sed -E 's|https://[^/]+/([^/]+)/.*|\1|')
            filename="public/${lang_code}.html"
            tmpfile="$(mktemp)"
          
            echo "Fetching $url -> $filename"
          
            ATTEMPTS=6
            success=false
          
            for attempt in $(seq 1 $ATTEMPTS); do
              echo "Attempt $attempt/$ATTEMPTS"
          
              http_code=$(curl -sS \
                --max-time 60 \
                --data-urlencode "url=$url" \
                --get \
                -w "%{http_code}" \
                -o "$tmpfile" \
                -H "x-bypass-cache: false" \
                "http://localhost:${PORT}/html" || echo "000")
          
              echo "HTTP status: $http_code"
          
              # 1. Must be HTTP 200
              if [ "$http_code" -ne 200 ]; then
                echo "Non-200 response"
                sleep 2
                continue
              fi
          
              # 2. Must not be empty
              if [ ! -s "$tmpfile" ]; then
                echo "Empty response body"
                sleep 2
                continue
              fi
          
              # 3. Reject JSON Cloudflare-bypass errors
              if grep -qiE '"detail"\s*:\s*"Failed to bypass Cloudflare protection"' "$tmpfile"; then
                echo "Proxy reported Cloudflare bypass failure (JSON error)"
                sleep 2
                continue
              fi
          
              # 4. Reject Cloudflare challenge HTML
              if grep -qiE \
                'cloudflare|cf-browser-verification|challenge-platform|Just a moment|Attention Required' \
                "$tmpfile"; then
                echo "Cloudflare challenge page detected"
                sleep 2
                continue
              fi
          
              # 5. Require actual HTML
              if ! grep -qi "<html" "$tmpfile"; then
                echo "Response is not HTML"
                sleep 2
                continue
              fi
          
              # SUCCESS
              mv "$tmpfile" "$filename"
              echo "Fetched $filename successfully."
              success=true
              break
            done
          
            rm -f "$tmpfile"
          
            if [ "$success" != true ]; then
              echo "FAILED to fetch valid content for $url"
              docker logs --tail 200 pagegen || true
              exit 1
            fi
          done

      - name: Stop and remove container
        if: always()
        run: |
          docker stop pagegen || true
          docker rm pagegen || true

      - name: Publish to GitHub Pages
        uses: peaceiris/actions-gh-pages@v3
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          publish_dir: ./public
          keep_files: true
          user_name: "github-actions[bot]"
          user_email: "noreply+gh-actions@users.noreply.github.com"
